# -*- coding: utf-8 -*-
"""Lane Detect (Without model).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mVd6w7T0-bwkjXf7CXUuGbDKKIp2vwCp
"""

import cv2 as cv
import numpy as np
import os
from google.colab import drive
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
import yaml
import glob
import matplotlib.image as mpimg
import pickle

# Mount Google Drive
drive.mount('/content/drive/')

"""# Data prep"""

# define the alpha and beta for contrast and brightness control
alpha = 1.5 # Contrast control
beta = 0.1 # Brightness control

def preprocess(img):
  mtx = pickle.load(open( "/content/drive/MyDrive/Otonomo/Birb/mtx.p", "rb" ))
  dist = pickle.load(open( "/content/drive/MyDrive/Otonomo/Birb/dist.p", "rb" ))
  undist = cv.undistort(img, mtx, dist, None, mtx)
  img_gray = cv.cvtColor(undist, cv.COLOR_BGR2GRAY) # Convert to grayscale


  img_size = (img_gray.shape[1], img_gray.shape[0])
  offset = 400
  source = np.float32([[1000,450],[1000, 720],[75,720],[200, 450]])
  destination = np.float32([[img_size[0], 0],
      [img_size[0]-offset, img_size[1]], [offset, img_size[1]],[0, 0]])

  M = cv.getPerspectiveTransform(source, destination)
  warped = cv.warpPerspective(img_gray, M, img_size)

  # call convertScaleAbs function
  #warped = cv.convertScaleAbs(warped, alpha=alpha, beta=beta)

  cv2_imshow(warped)
  print("Preprocessed image")
  return warped, M

"""
-->SORTING
-->PIPELINE
-->LINEDETECT
-->SAVE THE LABELS
---->   https://trello.com/1/cards/65aaab37e19ca772e6e05135/attachments/65d89b10cb3937f297d9f9fa/download/image.png   <------
"""
from scipy.ndimage import rotate
import re

threshold = (233,255)

# Define the natural sorting key function
def natural_key(string_):
    """See http://www.codinghorror.com/blog/archives/001018.html"""
    return [int(s) if s.isdigit() else s for s in re.split(r'(\d+)', string_)]

# Sort the image locations

#Pipeline
###to_binary from old code
def pipeline(img):
  print(img.shape)
  if len(img.shape) == 3:
        img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)

  ret, thresh = cv.threshold(img, 127, 255, cv.THRESH_BINARY)
  #cv2_imshow(thresh)

  return thresh

def left_line_detect(left_tracker, out_img, counter, x_current, width_sliding_window, minpix, nonzerox, nonzeroy, win_y_low, win_y_high, window_max):
    # Set the left location boundaries (create the rectangle box size)
    low_bound = x_current - width_sliding_window
    high_bound = x_current + width_sliding_window

    # Draw the rectangle around the lines
    cv.rectangle(out_img, (low_bound, win_y_low), (high_bound, win_y_high), (0, 255, 0), 2)
    # Show the image

    # Identify the nonzero pixels within the window
    non_zero_pix = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (nonzerox >= low_bound) & (nonzerox < high_bound)).nonzero()[0]

    # Recenter the window if enough pixels are found
    if len(non_zero_pix) > minpix:
        x_current = int(np.mean(nonzerox[non_zero_pix]))
    if counter >= 5:
      if win_y_high > window_max or low_bound < 0:
        left_tracker = False
    #print("LEFT", counter, left_tracker, end ="")
    return non_zero_pix, x_current


#Right Line
def right_line_detect(right_tracker, out_img, counter, x_current, width_sliding_window, minpix, nonzerox, nonzeroy, win_y_low, win_y_high, window_max):
  #Set the left location boundaries(create the rectangle box size)
  low_bound = x_current - width_sliding_window
  high_bound = x_current + width_sliding_window

  non_zero_pix = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) & (nonzerox >= low_bound) & (nonzerox < high_bound)).nonzero()[0]
  #Optional: Draw the recrangle around the lines
  cv.rectangle(out_img,(low_bound,win_y_low),(high_bound,win_y_high),(0,255,0), 2)
  # Show the image

  if len(non_zero_pix) > minpix:
    x_current = int(np.mean(nonzerox[non_zero_pix]))
  if counter >= 5:
    if win_y_high > window_max or low_bound < 0:
      right_tracker = False

  #print("RIGHT", counter, right_tracker, end ="")
  return non_zero_pix, x_current

def draw_poly(leftPoly, rightPoly, red_lines, og_img):
  if leftPoly is None or rightPoly is None:
        return
  # generate y-values for left and right polynomial fits
  ploty = np.linspace(0, red_lines.shape[0] - 1, red_lines.shape[0])
  left_fitx = leftPoly[0] * ploty ** 2 + leftPoly[1] * ploty + leftPoly[2]
  right_fitx = rightPoly[0] * ploty ** 2 + rightPoly[1] * ploty + rightPoly[2]

  # create an empty image to draw the polynomial curves
  out_img = np.copy(og_img)

  left_color = (0, 255, 0)   # Green
  right_color = (0, 0, 255)  # Blue

  # draw left and right polynomial curves on the empty image
  for i in range(len(ploty)):
      cv.circle(out_img, (int(left_fitx[i]), int(ploty[i])), 7, (0, 255, 0), -1)  # Left line
      cv.circle(out_img, (int(right_fitx[i]), int(ploty[i])), 7, (0, 0, 255), -1)  # Right line

  # overlay the polynomial curves on the original image
  result = cv.addWeighted(og_img, 1, out_img, 0.3, 0)
  result = cv.resize(result, (950, 534))
  print("1")
  cv2_imshow(result)

counter = 0
prev_right_poly = None
prev_left_poly = None

def lane_detection(image, lane_labels, counter, prev_left_poly, prev_right_poly):
  #itterate each image



  #pipeline the image
  red_lines = pipeline(image)

  #rotate the image by 20 degrees to left and right
  rotation = 20
  left = rotate(red_lines, rotation, reshape = False)
  right = rotate(red_lines, -rotation, reshape = False)

  #take the histogram of left, right and normal images (bottom half)
  hist_left = np.sum(left[int(left.shape[0]/2):,:], axis = 0)
  hist_right = np.sum(right[int(right.shape[0]/2):,:], axis = 0)
  hist_og = np.sum(red_lines[int(red_lines.shape[0]/2):,:], axis = 0)

  #stack and average the 3 histogram
  hist_stack = np.stack((hist_left, hist_right, hist_og))
  hist_stack = np.average(hist_stack, axis = 0)

  out_img = np.dstack((red_lines, red_lines, red_lines))*255

  #find the peaks of left and right halves of the histo for the starting points
  #print(hist_stack, hist_stack.shape)
  mid = int(hist_stack.shape[0]/2)
  lefthalf = np.argmax(hist_stack[:mid])
  righthalf = np.argmax(hist_stack[mid:]) + mid

  #number, width and height of the sliding windows, min number of pixels required to recenter the window
  num_sliding_window = 40
  width_sliding_window = 100
  height_sliding_window = int(red_lines.shape[0]/num_sliding_window)
  minpix = 50

  #identify the x and y positions of all non zero pixels
  #extract the row and column indices of the non-zero elements
  nonzero = red_lines.nonzero()
  nonzeroy = np.array(nonzero[0])
  nonzerox = np.array(nonzero[1])

  leftx_current = lefthalf
  rightx_current = righthalf

  #lists to track left and right (true/false)
  left_check = True
  right_check = True
  left_array = []
  right_array = []


  #WINDOW LOOP
  for window in range(num_sliding_window):

    #calculate the top and buttum y coordinates for the windows
    #assign the max x coordinate
    win_y_low = red_lines.shape[0] - (window + 1) * height_sliding_window
    win_y_high = red_lines.shape[0] - window * height_sliding_window
    window_max = red_lines.shape[1]

    if left_check == True and right_check == True:
      try:
        good_left_inds, leftx_current = left_line_detect(left_check, out_img, counter, leftx_current, width_sliding_window, minpix, nonzerox, nonzeroy, win_y_low, win_y_high, window_max)
        good_right_inds, rightx_current = right_line_detect(right_check, out_img, counter, rightx_current, width_sliding_window, minpix, nonzerox, nonzeroy, win_y_low, win_y_high, window_max)

        left_array.append(good_left_inds)
        right_array.append(good_right_inds)
        counter += 1
      except TypeError as e:
        print(f"Error: {e}. Skipping window {window}")
    elif left_check == True:
      try:
        good_left_inds, leftx_current = left_line_detect(left_check, out_img, counter, leftx_current, width_sliding_window, minpix, nonzerox, nonzeroy, win_y_low, win_y_high, window_max)
        left_array.append(good_left_inds)
      except TypeError as e:
        print(f"Error: {e}. Skipping window {window}")
    elif right_check == True:
      try:
        good_right_inds, rightx_current = right_line_detect(right_check, out_img, counter, rightx_current, width_sliding_window, minpix, nonzerox, nonzeroy, win_y_low, win_y_high, window_max)
        right_array.append(good_right_inds)
      except TypeError as e:
        print(f"Error: {e}. Skipping window {window}")
    else:
      break

  #concatenate the final left and right lists
  left_array = np.concatenate(left_array)
  right_array = np.concatenate(right_array)
  #print(left_array, right_array)

  #extract left x and y, right x and y
  leftx = nonzerox[left_array]
  lefty = nonzeroy[left_array]
  rightx = nonzerox[right_array]
  righty = nonzeroy[right_array]
  #fits 2nd order polynomial
  weight = 0.7

  # if lane_labels.pop() ==
  # past_label = lane_labels.pop()
  # prev_left_poly = past_label[0:3]
  # prev_right_poly = past_label[4:6]

  try:
    new_left_poly = np.polyfit(lefty, leftx, deg=2)
    if prev_left_poly is not None:
      leftPoly = weight * new_left_poly + (1 - weight) * prev_left_poly
    else:
      leftPoly = new_left_poly
  except TypeError as e:
    print(f"Polynomial fitting result is empty(LEFT), using previous valid polynomials")
    leftPoly = prev_left_poly

  prev_left_poly = leftPoly

  try:
    new_right_poly = np.polyfit(righty, rightx, deg=2)
    if prev_right_poly is not None:
      rightPoly = weight * new_right_poly + (1 - weight) * prev_right_poly
    else:
      rightPoly = new_right_poly
  except TypeError as e:
    print(f"Polynomial fitting result is empty(RIGHT), using previous valid polynomials")
    rightPoly = prev_right_poly

  prev_right_poly = rightPoly

  print("Left Poly: ", leftPoly, "Right Poly: ", rightPoly)

  draw_poly(leftPoly, rightPoly, red_lines, image)
  draw_poly(leftPoly, rightPoly, red_lines, out_img)
  #cv.polylines(out_img, rightPoly, isClosed = True, color = (255, 0, 0), thickness = 2)

  #print the polynomials to see the results
  # out_img = cv.resize(out_img, (500, 281))
  #print("2")
  #cv2_imshow(out_img)

  #append to the lane_labels list
  lane_labels.append(np.append(leftPoly, rightPoly))

#lane_labels declaration
lane_labels = []
route = []

road_img = []


def load_vid():

  # Get the location of the video and extract it
  vid_location = "/content/drive/MyDrive/pist.mp4"
  video = cv.VideoCapture(vid_location)
  success, frame = video.read()
  count = 0

  while success:
    #frame = cv.resize(frame, (160, 80))# Resize to desired size
    road_img.append(frame)
    count += 1
    #cv2_imshow(frame)

    #print("Loaded image", count)
    #image, M = preprocess(frame)

    #run lane_detection
    #lane_detection(image, lane_labels)

    if count % 10 == 0:
      print("Loaded image", count)
      image, M = preprocess(frame)

      #run lane_detection
      lane_detection(image, lane_labels, counter, prev_left_poly, prev_right_poly)


    success, frame = video.read()

  video.release()

#img_location = "/content/drive/MyDrive/Otonomo/raw.png"

#img = cv.imread(img_location)

#img, M = preprocess(img)

#lane_detection(img, lane_labels, counter, prev_left_poly, prev_right_poly)
load_vid()